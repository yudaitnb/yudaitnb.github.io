@article{kiuchi-pro-2024-5,
  author = {Kiuchi, Kosuke and Tanabe, Yudai and Masuhara, Hidehiko},
  title = {(Conditionally accepted) An Efficient Execution Mechanism on a GPU for Fine-Grained Parallel Programs With the Fork-Join Model},
  journal = {IPSJ Transactions on Programming},
  ISSN = {1882-7802},
  publisher = {Information Processing Society of Japan (IPSJ)},
  year = {2025},
  month = {},
  volume = {},
  number = {},
  pages = {},
  URL = {},
  abstract = {},
  abbr = {PRO},
  bibtex_show={true},
}

@article{kasuya-pro-2024-4,
  author = {Kasuya, Satsuki and Tanabe, Yudai and Masuhara, Hidehiko},
  title = {Dynamic Version Checking for Gradual Updating},
  journal = {Journal of Information Processing},
  ISSN = {1882-7802},
  publisher = {Information Processing Society of Japan (IPSJ)},
  year = {2025},
  month = {},
  volume = {},
  number = {},
  pages = {},
  URL = {},
  abstract = {Programming with Version (PWV) is a programming paradigm that allows programmers to safely utilize multiple versions of the same package within a single program, facilitating flexible version updates of dependent packages. Existing PWV languages ensure consistent version usage so as not to break software behaviors by leveraging the type system of the base language. However, dynamically typed languages need a mechanism to support multiple versions with an efficient method of ensuring consistent version usage without a type system. To introduce PWV features into dynamically typed languages, we propose a dynamic version checking (DVC) mechanism. It records version information in a value, propagates it during evaluation, and checks inconsistency using version information recorded in values. When an inconsistency is detected, the mechanism suggests how to modify the program to resolve potential semantic errors from the inconsistency. We develop Vython, a Python-based PWV language with DVC, and implement its compiler. The compiler translates a Vython program into a Python program with bitwise operations. Our performance measurement shows the DVC mechanism’s overhead is scalable and acceptable for small programs but requires further optimization for real-world use. Additionally, we conduct a case study and discuss future directions to facilitate smoother updates in practical development.},
  abbr = {JIP},
  bibtex_show={true},
}

@article{pldi24,
  author = {Igarashi, Atsushi and Ozaki, Shota and Sekiyama, Taro and Tanabe, Yudai},
  title = {Space-Efficient Polymorphic Gradual Typing, Mostly Parametric},
  year = {2024},
  issue_date = {June 2024},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  volume = {8},
  number = {PLDI},
  url = {https://doi.org/10.1145/3656441},
  doi = {10.1145/3656441},
  abstract = {Since the arrival of gradual typing, which allows partially typed code in a single program, efficient implementations of gradual typing have been an active research topic. In this paper, we study the space-efficiency problem of gradual typing in the presence of parametric polymorphism. Based on the existing work that showed the impossibility of a space-efficient implementation that supports fully parametric polymorphism, this paper will show that a space-efficient implementation is, in principle, possible by slightly relaxing parametricity. We first develop {$\lambda$C${}^{\forall}_{mp}$}, which is a coercion calculus with mostly parametric polymorphism, and show its relaxed parametricity. Then, we present {$\lambda$S${}^{\forall}_{mp}$}, a space-efficient version of {$\lambda$C${}^{\forall}_{mp}$}, and prove that {$\lambda$S${}^{\forall}_{mp}$} programs can be executed in a space-efficient manner and that translation from {$\lambda$C${}^{\forall}_{mp}$} to {$\lambda$S${}^{\forall}_{mp}$} is type- and semantics-preserving.},
  journal = {Proceedings of the ACM on Programming Languages (PACMPL)},
  month = {jun},
  articleno = {211},
  numpages = {24},
  keywords = {Gradual typing, Parametricity, Space efficiency},
  abbr = {PLDI},
  selected={true},
  bibtex_show={true},
  slides={jssst2024-invited.pdf},
}

@inproceedings{tanabe_compilation_2023,
	address = {Singapore},
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {Compilation {Semantics} for a {Programming} {Language} with {Versions}},
	copyright = {All rights reserved},
	isbn = {978-981-9983-11-7},
  url = {https://link.springer.com/chapter/10.1007/978-981-99-8311-7_1},
	doi = {10.1007/978-981-99-8311-7_1},
	abstract = {Programming with versions is a paradigm that allows a program to use multiple versions of a module so that the programmer can selectively use functions from both older and newer versions of a single module. Previous work formalized \$\${\textbackslash}lambda \_\{{\textbackslash}textrm\{VL\}\}\$\$λVL, a core calculus for programming with versions, but it has not been integrated into practical programming languages. In this paper, we propose VL, a Haskell-subset surface language for \$\${\textbackslash}lambda \_\{{\textbackslash}textrm\{VL\}\}\$\$λVLalong with its compilation method. We formally describe the core part of the VL compiler, which translates from the surface language to the core language by leveraging Girard’s translation, soundly infers the consistent version of expressions along with their types, and generates a multi-version interface by bundling specific-version interfaces. We conduct a case study to show how VL supports practical software evolution scenarios and discuss the method’s scalability.},
	language = {en},
	booktitle = {Programming {Languages} and {Systems}. APLAS 2023},
	publisher = {Springer Nature},
	author = {Tanabe, Yudai and Lubis, Luthfan Anshar and Aotani, Tomoyuki and Masuhara, Hidehiko},
	editor = {Hur, Chung-Kil},
	year = {2023},
	keywords = {Type inference, Type system, Version control system},
	pages = {3--23},
	file = {arXiv Fulltext PDF:/home/yudaitnb/Zotero/storage/7PNZBY55/Tanabe et al. - 2023 - Compilation Semantics for a Programming Language w.pdf:application/pdf;arXiv.org Snapshot:/home/yudaitnb/Zotero/storage/ECRU4UF7/2310.html:text/html;Full Text PDF:/home/yudaitnb/Zotero/storage/UHBL86FS/Tanabe et al. - 2023 - Compilation Semantics for a Programming Language w.pdf:application/pdf},
  arxiv = {2310.00298},
  abbr = {APLAS},
  selected={true},
  slides={aplas2023.pdf},
  slides2={ppl2024.pdf},
  bibtex_show={true},
  code = {https://github.com/yudaitnb/vl},
}


@book{tanabe_cop_2023,
	address = {New York, NY, USA},
	title = {{COP} 2023: {Proceedings} of the 15th {ACM} {International} {Workshop} on {Context}-{Oriented} {Programming} and {Advanced} {Modularity}},
	isbn = {9798400702440},
  url = {https://dl.acm.org/doi/proceedings/10.1145/3605154},
  doi = {10.1145/3605154},
	abstract = {Contextual information plays an ever-increasing role in our information-centric world. Current-day software systems adapt continuously to changing execution and usage contexts, even while running. Unfortunately, mainstream programming languages and development environments still do not support this kind of dynamicity very well, leading developers to implement complex designs to anticipate various dimensions of variability.},
	publisher = {Association for Computing Machinery},
	editor = {Tanabe, Yudai and Schütze, Lars and Hirschfeld, Robert and Igarashi, Atsushi and Masuhara, Hidehiko},
	year = {2023},
  abbr = {Proceedings},
  bibtex_show={true},
}


@inproceedings{tanabe_step_2022,
	address = {New York, NY, USA},
	series = {{COP} '22},
	title = {A {Step} toward {Programming} with {Versions} in {Real}-{World} {Functional} {Languages}},
	isbn = {978-1-4503-9986-9},
	url = {https://dl.acm.org/doi/10.1145/3570353.3570359},
	doi = {10.1145/3570353.3570359},
	abstract = {λVL is a core calculus based on the concept of programming with versions that supports multiple versions of program definitions and values inherently in the semantics of a language. However, since λVL was not designed as a surface language, its complex syntax and semantics only provide primitive constructs to manipulate versioned values. In order to realize the programming with versions concept in a real-world language, we propose a compilation method for functional languages through λVL and discuss how real-world programs can be written in a Haskell-like functional language with versions.},
	urldate = {2023-07-13},
	booktitle = {Proceedings of the 14th {ACM} {International} {Workshop} on {Context}-{Oriented} {Programming} and {Advanced} {Modularity}},
	publisher = {Association for Computing Machinery},
	author = {Tanabe, Yudai and Lubis, Luthfan Anshar and Aotani, Tomoyuki and Masuhara, Hidehiko},
	month = dec,
	year = {2022},
	keywords = {Coeffects, Graded modal types, dependencies, Program evolution, software product lines},
	pages = {44--51},
	file = {Full Text PDF:/home/yudaitnb/Zotero/storage/I35TPMHV/Tanabe et al. - 2022 - A Step toward Programming with Versions in Real-Wo.pdf:application/pdf},
  abbr = {COP},
  bibtex_show={true},
  slides={cop2022.pdf},
}

@book{tanabe_cop_2022,
	address = {New York, NY, USA},
	title = {{COP} '22: {Proceedings} of the 14th {ACM} {International} {Workshop} on {Context}-{Oriented} {Programming} and {Advanced} {Modularity}},
  url = {https://dl.acm.org/doi/proceedings/10.1145/3570353},
  doi = {10.1145/3570353},
	isbn = {978-1-4503-9986-9},
	publisher = {Association for Computing Machinery},
	editor = {Tanabe, Yudai and Lincke, Jens and Hirschfeld, Robert and Igarashi, Atsushi and Masuhara, Hidehiko},
	year = {2022},
  abbr = {Proceedings},
  bibtex_show={true},
}

@inproceedings{lubis_batakjava_2022,
	address = {New York, NY, USA},
	series = {{SLE} 2022},
	title = {{BatakJava}: {An} {Object}-{Oriented} {Programming} {Language} with {Versions}},
	isbn = {978-1-4503-9919-7},
	shorttitle = {{BatakJava}},
	url = {https://dl.acm.org/doi/10.1145/3567512.3567531},
	doi = {10.1145/3567512.3567531},
	abstract = {Programming with versions is a recent proposal that supports multiple versions of software components in a program. Though it would provide greater freedom for the programmer, the concept is only realized as a simple core calculus, called λVL, where a value consists of λ-terms with multiple versions. We explore a design space of programming with versions in the presence of data structures and module systems, and propose BatakJava, an object-oriented programming language in which multiple versions of a class can be used in a program. This paper presents BatakJava’s language design, its core semantics with subject reduction, an implementation as a source-to-Java translator, and a case study to understand how we can exploit multiple versions in BatakJava for developing an application program with an evolving library.},
	urldate = {2023-07-13},
	booktitle = {Proceedings of the 15th {ACM} {SIGPLAN} {International} {Conference} on {Software} {Language} {Engineering}},
	publisher = {Association for Computing Machinery},
	author = {Lubis, Luthfan Anshar and Tanabe, Yudai and Aotani, Tomoyuki and Masuhara, Hidehiko},
	month = dec,
	year = {2022},
	keywords = {Java, backward compatibility, dependency problem},
	pages = {222--234},
	file = {Full Text PDF:/home/yudaitnb/Zotero/storage/LLDZKRW3/Lubis et al. - 2022 - BatakJava An Object-Oriented Programming Language.pdf:application/pdf},
  abbr = {SLE},
  bibtex_show={true},
}

@article{tanabe_functional_2021,
	title = {A {Functional} {Programming} {Language} with {Versions}},
	volume = {6},
	issn = {2473-7321},
	url = {https://programming-journal.org/2022/6/5/},
	doi = {10.22152/programming-journal.org/2022/6/5},
	abstract = {While modern software development heavily uses versioned packages, programming languages rarely support the concept of versions in their semantics, which makes software updates more bulky and unsafe. This paper proposes a programming language that intrinsically supports versions. The main goals are to design core language features to support multiple versions in one program and establish a proper notion of type safety with those features. The proposed core calculus, called Lambda VL, has versioned values, each containing different values under different versions. We show the construction of the type system as an extension of coeffect calculus by mapping versions to computational resources. The type system guarantees the existence of a valid combination of versions for a program. The calculus enables programming languages to use multiple versions of a package within a program. It will serve as a basis for designing advanced language features like module systems and semantic versioning.},
	language = {en},
	number = {1},
	urldate = {2023-07-14},
	journal = {The Art, Science, and Engineering of Programming},
	author = {Tanabe, Yudai and Lubis, Luthfan Anshar and Aotani, Tomoyuki and Masuhara, Hidehiko},
	month = jul,
	year = {2021},
	pages = {5:1--5:30},
	file = {Full Text PDF:/home/yudaitnb/Zotero/storage/926DBKAG/Tanabe et al. - 2021 - A Functional Programming Language with Versions.pdf:application/pdf},
  abbr = {‹Programming›},
  selected={true},
  slides={progamming2022.pdf},
  bibtex_show={true},
  slides2={programming2023.pdf},
}

@inproceedings{tanabe_context-oriented_2018,
	address = {New York, NY, USA},
	series = {{COP} '18},
	title = {A {Context}-{Oriented} {Programming} {Approach} to {Dependency} {Hell}},
	isbn = {978-1-4503-5722-7},
	url = {https://dl.acm.org/doi/10.1145/3242921.3242923},
	doi = {10.1145/3242921.3242923},
	abstract = {Two or more incompatible versions of a library are sometimes needed in one software artifact, which is so-called dependency hell. One likely faces the problem if he or she uses two or more libraries that depend on the same library. In this paper, we propose versioned values to solve the problem. They allow us to have multiple versions of functions in a binary file. This gets rid of requiring two or more incompatible binaries. We develop a calculus λVL to discuss type safety in the case where definitions are available only in specific versions, which is a common and important nature of versioned programs.},
	urldate = {2023-07-13},
	booktitle = {Proceedings of the 10th {ACM} {International} {Workshop} on {Context}-{Oriented} {Programming}: {Advanced} {Modularity} for {Run}-time {Composition}},
	publisher = {Association for Computing Machinery},
	author = {Tanabe, Yudai and Aotani, Tomoyuki and Masuhara, Hidehiko},
	month = jul,
	year = {2018},
	keywords = {Coeffects, Context-Oriented Programming, Contexts},
	pages = {8--14},
	file = {Full Text PDF:/home/yudaitnb/Zotero/storage/RA88VSWR/Tanabe et al. - 2018 - A Context-Oriented Programming Approach to Depende.pdf:application/pdf},
  abbr = {COP},
  postprint = {assets/pdf/COP18_rev.pdf},
  bibtex_show={true},
  slides = {cop2018.pdf},
}