@inproceedings{yoshimura-ppl2026,  
	address = {Takamatsu, Kagawa, Japan},
	series = {{PPL} '26},
  title = {A Lightweight Implementation for Efficient Multi-Stage Computation Using a Tracing JIT Compiler (トレーシングJITコンパイラを用いた多段階計算の高速かつ簡易な実行方式)},
  url = {https://prg.is.titech.ac.jp/ja/news/ppl2026-c1/},
  abstract = {多段階計算は実行時コード生成と生成されたコードの実行を行う機能を備えたメタプログラミング機構である。多段階計算の実行時性能はコード生成オーバヘッドおよび生成コードの品質の両方に依存するが、従来方式ではこれらの両立が困難であった。本研究はトレーシングJITコンパイラを多段階計算のコード生成機構として利用する新たな実行方式を提案する。提案方式では、多段階計算プログラムを実行前にクロージャベースの一段階計算へ変換し、実行時にはトレーシングJITによりクロージャ呼び出しをインライン化する。本手法によりコード生成の軽量性と生成コードの実行性能の両立を、低労力で実現することが期待できる。提案方式による多段階計算言語の実装に向けた予備評価として、提案方式をPyPy上に実装し、累乗計算およびDSLインタプリタを含むベンチマークでMetaOCamlと比較評価した。その結果、一定の条件下では提案方式が従来方式を上回る性能を示した。},
	language = {jp},
  booktitle = {Proceedings of the the 28th Workshop on Programming and Programming Languages (PPL2026)},
  organization = {Special Interest Group on Programming and Programming Languages, {J}apan Society for Software Science and Technology (JSSST-SIGPPL)},
  howpublished = {The 28th Workshop on Programming and Programming Languages (PPL2026)},
  pdf = {https://prg.is.titech.ac.jp/ja/news/ppl2026-c1/},
  author = {Yoshimura, Yusei and Tanabe, Yudai and Masuhara, Hidehiko},
	editor = {Nishida, Naoki and Soh, Takahide},
  month = {mar},
	year = {2026},
  abbr = {PPL},
  selected={false},
  bibtex_show={true},
}

@inproceedings{peien-ppl2026,
	address = {Takamatsu, Kagawa, Japan},
	series = {{PPL} '26},
  title = {Towards Borrowable Ownership Types with Algebraic Effect Handlers},
  url = {https://prg.is.titech.ac.jp/ja/news/ppl2026-c1/},
  abstract = {Algebraic effect handlers enable modular effectful programming, reifying continuations as first-class values. Although the use of continuations allows implementing various control effects within programs, multi-shot continuations hinder safe resource management: they may lead to double-free and use-after-free. To reconcile safe resource management with effect handlers, we introduce Rust-style ownership to them. The ownership ensures that resources are freed only by their owners. Therefore, we can guarantee the absence of double-free and use-after-free by requiring that resources be owned when they are freed. Rust-style ownership also enables tentatively borrowing resources, helping enhance the flexible use of continuations: if continuations require resources' ownership, they can be used only once; however, the continuations that only borrow resources can be called multiple times. To formalize our idea, we present OBEff, a calculus integrating Rust-style ownership and algebraic effect handlers. The major challenges lying in the integration are twofold. First, since continuations may include free variables and they are reified as function values, we have to support open functions. This is challenging in Rust-style ownership because we need to track what resources are captured and how (owned or borrowed). The second is to address non-local control flow by effect handlers in the presence of local regions. The paper discusses the directions OBEff should take to address these challenges.},
	language = {en},
  booktitle = {Proceedings of the the 28th Workshop on Programming and Programming Languages (PPL2026)},
  organization = {Special Interest Group on Programming and Programming Languages, {J}apan Society for Software Science and Technology (JSSST-SIGPPL)},
  howpublished = {The 28th Workshop on Programming and Programming Languages (PPL2026)},
  pdf = {https://prg.is.titech.ac.jp/ja/news/ppl2026-c1/},
  author = {Chen, Peien and Tanabe, Yudai and Sekiyama, Taro},
	editor = {Nishida, Naoki and Soh, Takahide},
  month = {mar},
	year = {2026},
  abbr = {PPL},
  selected={false},
  bibtex_show={true},
}



@inproceedings{kasuya-ppl2026,
	address = {Takamatsu, Kagawa, Japan},
	series = {{PPL} '26},
  title = {Multi-Version Objects: Mediating Object Access in Mixed-Version Programs for Python},
  url = {https://prg.is.titech.ac.jp/ja/news/ppl2026-c1/},
  abstract = {Long-lived software often consists of mixed-version code within a single process during rolling updates or when legacy components must be maintained alongside newer ones. Such software maintains data shared across code versions, each expecting a different representation (e.g., missing or renamed fields, changed invariants). Yet, conventional runtimes create objects with a single, version-specific representation. This forces developers to separate objects or insert ad-hoc adapters, complicating maintenance. We propose Multi-Version Objects (MVO), a runtime object model that supports one logical object with multiple version-specific representations. MVO routes attribute access and method calls to a version chosen by a configurable version-selection strategy among structurally compatible versions (e.g., matching names and parameter conventions). On switching versions, MVO performs on-demand, bidirectional state transformation between representations, using upstream-provided conversion functions, allowing downstream call sites stay version-agnostic and avoid pervasive adapters. We consider two version-selection policies: (i) continuity-first, which prioritizes the most recent access version to reduce thrashing, and (ii) latest-first, which prioritizes the newest version to encourage convergence. We implement a prototype compiler targeting CPython and evaluate the runtime overhead and how observed incompatibilities in real PyPI package upgrades can be captured as bidirectional conversions, and case studies comparing version-selection strategies.},
	language = {en},
  booktitle = {Proceedings of the the 28th Workshop on Programming and Programming Languages (PPL2026)},
  organization = {Special Interest Group on Programming and Programming Languages, {J}apan Society for Software Science and Technology (JSSST-SIGPPL)},
  howpublished = {The 28th Workshop on Programming and Programming Languages (PPL2026)},
  pdf = {https://prg.is.titech.ac.jp/ja/news/ppl2026-c1/},
  author = {Kasuya, Satsuki and Tanabe, Yudai and Masuhara, Hidehiko},
	editor = {Nishida, Naoki and Soh, Takahide},
  month = {mar},
	year = {2026},
  abbr = {PPL},
  selected={false},
  bibtex_show={true},
}

@article{kiuchi-pro-2024-5,
  author = {Kiuchi, Kosuke and Tanabe, Yudai and Masuhara, Hidehiko},
  title = {An Efficient Execution Mechanism on a GPU for Fine-Grained Parallel Programs With the Fork-Join Model},
  journal = {Journal of Information Processing},
  ISSN = {1882-7802},
  publisher = {Information Processing Society of Japan (IPSJ)},
  year = {2025},
  month = {},
  volume = {33},
  number = {},
  pages = {840-851},
  doi={10.2197/ipsjjip.33.840},
  URL = {https://www.jstage.jst.go.jp/article/ipsjjip/33/0/33_840/_article},
  abstract = {General purpose computing on graphics processing units (GPGPU) has an execution model in which the number and type of parallel tasks are managed by the CPU, making it difficult to execute fine-grained parallel programs efficiently with nested parallel tasks at a nonhomogeneous granularity. This work addresses this problem by efficiently executing fine-grained parallel programs by managing parallel tasks on the GPU using a fast memory allocation mechanism. As a preliminary implementation, this work proposes a method for splitting the computation in a fine-grained parallel fork-join program at the fork point and allocating each computation to the GPU memory as a parallel task. In addition, kernel fusion, parallel task reuse, and parallel throttling are explored as optimization methods for the proposed method. This work implements a fine-grained parallel fork-join program in CUDA and investigates its scalability and execution speed to evaluate the feasibility and performance of the proposed method.},
  abbr = {JIP},
  bibtex_show={true},
}

@article{kasuya-pro-2024-4,
  author = {Kasuya, Satsuki and Tanabe, Yudai and Masuhara, Hidehiko},
  title = {Dynamic Version Checking for Gradual Updating},
  journal = {Journal of Information Processing},
  ISSN = {1882-7802},
  publisher = {Information Processing Society of Japan (IPSJ)},
  year = {2025},
  month = {},
  volume={33},
  number={ },
  pages={471-486},
  doi={10.2197/ipsjjip.33.471},
  URL = {https://www.jstage.jst.go.jp/article/ipsjjip/33/0/33_471/_article},
  abstract = {Programming with Version (PWV) is a programming paradigm that allows programmers to safely utilize multiple versions of the same package within a single program, facilitating flexible version updates of dependent packages. Existing PWV languages ensure consistent version usage so as not to break software behaviors by leveraging the type system of the base language. However, dynamically typed languages need a mechanism to support multiple versions with an efficient method of ensuring consistent version usage without a type system. To introduce PWV features into dynamically typed languages, we propose a dynamic version checking (DVC) mechanism. It records version information in a value, propagates it during evaluation, and checks inconsistency using version information recorded in values. When an inconsistency is detected, the mechanism suggests how to modify the program to resolve potential semantic errors from the inconsistency. We develop Vython, a Python-based PWV language with DVC, and implement its compiler. The compiler translates a Vython program into a Python program with bitwise operations. Our performance measurement shows the DVC mechanism’s overhead is scalable and acceptable for small programs but requires further optimization for real-world use. Additionally, we conduct a case study and discuss future directions to facilitate smoother updates in practical development.},
  abbr = {JIP},
  bibtex_show={true},
}

@article{pldi24,
  author = {Igarashi, Atsushi and Ozaki, Shota and Sekiyama, Taro and Tanabe, Yudai},
  title = {Space-Efficient Polymorphic Gradual Typing, Mostly Parametric},
  year = {2024},
  issue_date = {June 2024},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  volume = {8},
  number = {PLDI},
  url = {https://doi.org/10.1145/3656441},
  doi = {10.1145/3656441},
  abstract = {Since the arrival of gradual typing, which allows partially typed code in a single program, efficient implementations of gradual typing have been an active research topic. In this paper, we study the space-efficiency problem of gradual typing in the presence of parametric polymorphism. Based on the existing work that showed the impossibility of a space-efficient implementation that supports fully parametric polymorphism, this paper will show that a space-efficient implementation is, in principle, possible by slightly relaxing parametricity. We first develop {$\lambda$C${}^{\forall}_{mp}$}, which is a coercion calculus with mostly parametric polymorphism, and show its relaxed parametricity. Then, we present {$\lambda$S${}^{\forall}_{mp}$}, a space-efficient version of {$\lambda$C${}^{\forall}_{mp}$}, and prove that {$\lambda$S${}^{\forall}_{mp}$} programs can be executed in a space-efficient manner and that translation from {$\lambda$C${}^{\forall}_{mp}$} to {$\lambda$S${}^{\forall}_{mp}$} is type- and semantics-preserving.},
  journal = {Proceedings of the ACM on Programming Languages (PACMPL)},
  month = {jun},
  articleno = {211},
  numpages = {24},
  keywords = {Gradual typing, Parametricity, Space efficiency},
  abbr = {PLDI},
  selected={true},
  bibtex_show={true},
  slides={jssst2024-invited.pdf},
}

@article{tanabe_compilation_2023,
	address = {Singapore},
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {Compilation {Semantics} for a {Programming} {Language} with {Versions}},
	copyright = {All rights reserved},
	isbn = {978-981-9983-11-7},
  url = {https://link.springer.com/chapter/10.1007/978-981-99-8311-7_1},
	doi = {10.1007/978-981-99-8311-7_1},
	abstract = {Programming with versions is a paradigm that allows a program to use multiple versions of a module so that the programmer can selectively use functions from both older and newer versions of a single module. Previous work formalized \$\${\textbackslash}lambda \_\{{\textbackslash}textrm\{VL\}\}\$\$λVL, a core calculus for programming with versions, but it has not been integrated into practical programming languages. In this paper, we propose VL, a Haskell-subset surface language for \$\${\textbackslash}lambda \_\{{\textbackslash}textrm\{VL\}\}\$\$λVLalong with its compilation method. We formally describe the core part of the VL compiler, which translates from the surface language to the core language by leveraging Girard’s translation, soundly infers the consistent version of expressions along with their types, and generates a multi-version interface by bundling specific-version interfaces. We conduct a case study to show how VL supports practical software evolution scenarios and discuss the method’s scalability.},
	language = {en},
	booktitle = {Programming {Languages} and {Systems}. APLAS 2023},
	publisher = {Springer Nature},
	author = {Tanabe, Yudai and Lubis, Luthfan Anshar and Aotani, Tomoyuki and Masuhara, Hidehiko},
	editor = {Hur, Chung-Kil},
	year = {2023},
	keywords = {Type inference, Type system, Version control system},
	pages = {3--23},
  arxiv = {2310.00298},
  abbr = {APLAS},
  selected={true},
  slides={aplas2023.pdf},
  slides2={ppl2024.pdf},
  bibtex_show={true},
  code = {https://github.com/yudaitnb/vl},
}


@book{tanabe_cop_2023,
	address = {New York, NY, USA},
	title = {{COP} 2023: {Proceedings} of the 15th {ACM} {International} {Workshop} on {Context}-{Oriented} {Programming} and {Advanced} {Modularity}},
	isbn = {9798400702440},
  url = {https://dl.acm.org/doi/proceedings/10.1145/3605154},
  doi = {10.1145/3605154},
	abstract = {Contextual information plays an ever-increasing role in our information-centric world. Current-day software systems adapt continuously to changing execution and usage contexts, even while running. Unfortunately, mainstream programming languages and development environments still do not support this kind of dynamicity very well, leading developers to implement complex designs to anticipate various dimensions of variability.},
	publisher = {Association for Computing Machinery},
	editor = {Tanabe, Yudai and Schütze, Lars and Hirschfeld, Robert and Igarashi, Atsushi and Masuhara, Hidehiko},
	year = {2023},
  abbr = {Proceedings},
  bibtex_show={true},
}


@inproceedings{tanabe_step_2022,
	address = {New York, NY, USA},
	series = {{COP} '22},
	title = {A {Step} toward {Programming} with {Versions} in {Real}-{World} {Functional} {Languages}},
	isbn = {978-1-4503-9986-9},
	url = {https://dl.acm.org/doi/10.1145/3570353.3570359},
	doi = {10.1145/3570353.3570359},
	abstract = {λVL is a core calculus based on the concept of programming with versions that supports multiple versions of program definitions and values inherently in the semantics of a language. However, since λVL was not designed as a surface language, its complex syntax and semantics only provide primitive constructs to manipulate versioned values. In order to realize the programming with versions concept in a real-world language, we propose a compilation method for functional languages through λVL and discuss how real-world programs can be written in a Haskell-like functional language with versions.},
	urldate = {2023-07-13},
	booktitle = {Proceedings of the 14th {ACM} {International} {Workshop} on {Context}-{Oriented} {Programming} and {Advanced} {Modularity}},
	publisher = {Association for Computing Machinery},
	author = {Tanabe, Yudai and Lubis, Luthfan Anshar and Aotani, Tomoyuki and Masuhara, Hidehiko},
	month = dec,
	year = {2022},
	keywords = {Coeffects, Graded modal types, dependencies, Program evolution, software product lines},
	pages = {44--51},
  abbr = {COP},
  bibtex_show={true},
  slides={cop2022.pdf},
}

@book{tanabe_cop_2022,
	address = {New York, NY, USA},
	title = {{COP} '22: {Proceedings} of the 14th {ACM} {International} {Workshop} on {Context}-{Oriented} {Programming} and {Advanced} {Modularity}},
  url = {https://dl.acm.org/doi/proceedings/10.1145/3570353},
  doi = {10.1145/3570353},
	isbn = {978-1-4503-9986-9},
	publisher = {Association for Computing Machinery},
	editor = {Tanabe, Yudai and Lincke, Jens and Hirschfeld, Robert and Igarashi, Atsushi and Masuhara, Hidehiko},
	year = {2022},
  abbr = {Proceedings},
  bibtex_show={true},
}

@inproceedings{lubis_batakjava_2022,
	address = {New York, NY, USA},
	series = {{SLE} 2022},
	title = {{BatakJava}: {An} {Object}-{Oriented} {Programming} {Language} with {Versions}},
	isbn = {978-1-4503-9919-7},
	shorttitle = {{BatakJava}},
	url = {https://dl.acm.org/doi/10.1145/3567512.3567531},
	doi = {10.1145/3567512.3567531},
	abstract = {Programming with versions is a recent proposal that supports multiple versions of software components in a program. Though it would provide greater freedom for the programmer, the concept is only realized as a simple core calculus, called λVL, where a value consists of λ-terms with multiple versions. We explore a design space of programming with versions in the presence of data structures and module systems, and propose BatakJava, an object-oriented programming language in which multiple versions of a class can be used in a program. This paper presents BatakJava’s language design, its core semantics with subject reduction, an implementation as a source-to-Java translator, and a case study to understand how we can exploit multiple versions in BatakJava for developing an application program with an evolving library.},
	urldate = {2023-07-13},
	booktitle = {Proceedings of the 15th {ACM} {SIGPLAN} {International} {Conference} on {Software} {Language} {Engineering}},
	publisher = {Association for Computing Machinery},
	author = {Lubis, Luthfan Anshar and Tanabe, Yudai and Aotani, Tomoyuki and Masuhara, Hidehiko},
	month = dec,
	year = {2022},
	keywords = {Java, backward compatibility, dependency problem},
	pages = {222--234},
  abbr = {SLE},
  bibtex_show={true},
}

@article{tanabe_functional_2021,
	title = {A {Functional} {Programming} {Language} with {Versions}},
	volume = {6},
	issn = {2473-7321},
	url = {https://programming-journal.org/2022/6/5/},
	doi = {10.22152/programming-journal.org/2022/6/5},
	abstract = {While modern software development heavily uses versioned packages, programming languages rarely support the concept of versions in their semantics, which makes software updates more bulky and unsafe. This paper proposes a programming language that intrinsically supports versions. The main goals are to design core language features to support multiple versions in one program and establish a proper notion of type safety with those features. The proposed core calculus, called Lambda VL, has versioned values, each containing different values under different versions. We show the construction of the type system as an extension of coeffect calculus by mapping versions to computational resources. The type system guarantees the existence of a valid combination of versions for a program. The calculus enables programming languages to use multiple versions of a package within a program. It will serve as a basis for designing advanced language features like module systems and semantic versioning.},
	language = {en},
	number = {1},
	urldate = {2023-07-14},
	journal = {The Art, Science, and Engineering of Programming},
	author = {Tanabe, Yudai and Lubis, Luthfan Anshar and Aotani, Tomoyuki and Masuhara, Hidehiko},
	month = jul,
	year = {2021},
	pages = {5:1--5:30},
  abbr = {‹Programming›},
  selected={true},
  slides={progamming2022.pdf},
  bibtex_show={true},
  slides2={programming2023.pdf},
}

@inproceedings{tanabe_context-oriented_2018,
	address = {New York, NY, USA},
	series = {{COP} '18},
	title = {A {Context}-{Oriented} {Programming} {Approach} to {Dependency} {Hell}},
	isbn = {978-1-4503-5722-7},
	url = {https://dl.acm.org/doi/10.1145/3242921.3242923},
	doi = {10.1145/3242921.3242923},
	abstract = {Two or more incompatible versions of a library are sometimes needed in one software artifact, which is so-called dependency hell. One likely faces the problem if he or she uses two or more libraries that depend on the same library. In this paper, we propose versioned values to solve the problem. They allow us to have multiple versions of functions in a binary file. This gets rid of requiring two or more incompatible binaries. We develop a calculus λVL to discuss type safety in the case where definitions are available only in specific versions, which is a common and important nature of versioned programs.},
	urldate = {2023-07-13},
	booktitle = {Proceedings of the 10th {ACM} {International} {Workshop} on {Context}-{Oriented} {Programming}: {Advanced} {Modularity} for {Run}-time {Composition}},
	publisher = {Association for Computing Machinery},
	author = {Tanabe, Yudai and Aotani, Tomoyuki and Masuhara, Hidehiko},
	month = jul,
	year = {2018},
	keywords = {Coeffects, Context-Oriented Programming, Contexts},
	pages = {8--14},
  abbr = {COP},
  postprint = {assets/pdf/COP18_rev.pdf},
  bibtex_show={true},
  slides = {cop2018.pdf},
}